<!DOCTYPE html>
<html>
<head>
    <title>Farming Simulation</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>{{ farm_name or 'Farming Simulation' }}</h1>
    
    <div class="farm-grid" id="farm-grid">
        {% for i in range(400) %}
        <div class="grid-cell" data-position="{{ i }}" data-row="{{ (i // 20) }}" data-col="{{ (i % 20) }}">
            {% if farm_grid.get(i|string) %}
                <span class="object-emoji">{{ farm_grid[i|string]['emoji'] }}</span>
            {% endif %}
        </div>
        {% endfor %}
    </div>

    <!-- Farm Object Addition UI -->
    <div class="object-controls">
        <h2>Farm Objects</h2>
        <p class="instructions">Drag objects from the palette below to the grid, or drag objects between grid cells</p>
        
        <div class="control-section">
            <button id="remove-object-btn" onclick="enableRemovalMode()" style="background-color: #e74c3c;">
                Remove Object Mode
            </button>
        </div>

        <!-- Object Palette -->
        <div class="object-palette">
            <div class="palette-section">
                <h3>üêÑ Animals</h3>
                <div class="object-items" id="animals-palette">
                    <!-- Animals will be populated here -->
                </div>
            </div>
            
            <div class="palette-section">
                <h3>üåæ Crops</h3>
                <div class="object-items" id="crops-palette">
                    <!-- Crops will be populated here -->
                </div>
            </div>
            
            <div class="palette-section">
                <h3>üöú Tools</h3>
                <div class="object-items" id="tools-palette">
                    <!-- Tools will be populated here -->
                </div>
            </div>
        </div>

        <div class="info-section">
            <div id="object-info"></div>
            <div id="removal-instructions" style="display: none;">
                Click on an object to remove it from the grid
            </div>
            <div id="drag-feedback" class="drag-feedback"></div>
        </div>
    </div>

    <script>
        // Farm objects data passed from Flask
        const farmObjects = JSON.parse('{{ farm_objects | tojson | safe }}');
        let removalMode = false;
        let draggedElement = null;
        let draggedObjectData = null;

        // Initialize the drag and drop functionality
        document.addEventListener('DOMContentLoaded', function() {
            createObjectPalette();
            positionFlatGrid();
            setupGridDropZones();
            setupGridObjectDragging();
        });

        function createObjectPalette() {
            // Create animals palette
            const animalsContainer = document.getElementById('animals-palette');
            farmObjects.animals.forEach(animal => {
                animalsContainer.appendChild(createDraggableObject(animal, 'animals'));
            });

            // Create crops palette
            const cropsContainer = document.getElementById('crops-palette');
            farmObjects.crops.forEach(crop => {
                cropsContainer.appendChild(createDraggableObject(crop, 'crops'));
            });

            // Create tools palette
            const toolsContainer = document.getElementById('tools-palette');
            farmObjects.tools.forEach(tool => {
                toolsContainer.appendChild(createDraggableObject(tool, 'tools'));
            });
        }

        function createDraggableObject(objectData, category) {
            const element = document.createElement('div');
            element.className = 'draggable-object';
            element.draggable = true;
            element.innerHTML = `
                <div class="emoji">${objectData.emoji}</div>
                <div class="name">${objectData.name}</div>
                <div class="value">$${objectData.value}</div>
            `;

            // Store object data
            element.objectData = objectData;
            element.category = category;
            element.isFromPalette = true;

            // Add drag event listeners
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);

            // Add hover events for info display
            element.addEventListener('mouseenter', () => showObjectInfo(objectData));
            element.addEventListener('mouseleave', () => clearObjectInfo());

            return element;
        }

        function showObjectInfo(obj) {
            const infoDiv = document.getElementById('object-info');
            let info = `<strong>${obj.emoji} ${obj.name}</strong><br>Value: $${obj.value}`;
            
            if (obj.age) info += `<br>Age: ${obj.age} years`;
            if (obj.growth_time) info += `<br>Growth Time: ${obj.growth_time} days`;
            
            infoDiv.innerHTML = info;
        }

        function clearObjectInfo() {
            document.getElementById('object-info').innerHTML = '';
        }

        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            
            // Store drag data
            if (this.isFromPalette) {
                draggedObjectData = {
                    type: 'new',
                    objectData: this.objectData,
                    category: this.category
                };
            } else {
                draggedObjectData = {
                    type: 'existing',
                    fromPosition: this.parentElement.dataset.position
                };
            }

            // Set drag effect
            e.dataTransfer.effectAllowed = 'move';
            
            // Update feedback
            updateDragFeedback(`Dragging ${this.objectData ? this.objectData.name : 'object'}...`);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            draggedObjectData = null;
            clearDragFeedback();
        }

        function setupGridDropZones() {
            const gridCells = document.querySelectorAll('.grid-cell');
            
            gridCells.forEach(cell => {
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('dragenter', handleDragEnter);
                cell.addEventListener('dragleave', handleDragLeave);
                cell.addEventListener('drop', handleDrop);
                
                // Add click handler for removal mode
                cell.addEventListener('click', function() {
                    if (removalMode) {
                        removeObject(this.dataset.position);
                    }
                });
            });
        }

        function setupGridObjectDragging() {
            // Make existing objects on grid draggable
            const gridCells = document.querySelectorAll('.grid-cell');
            gridCells.forEach(cell => {
                const emoji = cell.querySelector('.object-emoji');
                if (emoji) {
                    makeGridObjectDraggable(cell, emoji);
                }
            });
        }

        function makeGridObjectDraggable(cell, emojiElement) {
            emojiElement.draggable = true;
            emojiElement.addEventListener('dragstart', function(e) {
                draggedElement = this;
                this.style.opacity = '0.5';
                
                draggedObjectData = {
                    type: 'existing',
                    fromPosition: cell.dataset.position
                };
                
                e.dataTransfer.effectAllowed = 'move';
                updateDragFeedback('Moving object...');
            });
            
            emojiElement.addEventListener('dragend', function(e) {
                this.style.opacity = '1';
                draggedElement = null;
                draggedObjectData = null;
                clearDragFeedback();
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (!this.classList.contains('occupied')) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            // Only remove highlight if we're actually leaving the cell
            if (!this.contains(e.relatedTarget)) {
                this.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            const position = this.dataset.position;
            
            // Don't allow dropping on occupied cells
            if (this.classList.contains('occupied')) {
                updateDragFeedback('Position already occupied!');
                setTimeout(clearDragFeedback, 2000);
                return;
            }

            if (draggedObjectData.type === 'new') {
                // Placing new object from palette
                placeNewObject(position, draggedObjectData.objectData, draggedObjectData.category);
            } else if (draggedObjectData.type === 'existing') {
                // Moving existing object
                moveExistingObject(draggedObjectData.fromPosition, position);
            }
        }

        function placeNewObject(position, objectData, category) {
            const objectType = category === 'animals' ? 'Animal' : 
                             category === 'crops' ? 'Crop' : 'Tool';
            
            fetch('/add_object', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    position: position,
                    name: objectData.name,
                    type: objectType
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const cell = document.querySelector(`[data-position="${position}"]`);
                    const emojiElement = document.createElement('span');
                    emojiElement.className = 'object-emoji';
                    emojiElement.textContent = data.object.emoji;
                    
                    cell.innerHTML = '';
                    cell.appendChild(emojiElement);
                    cell.classList.add('occupied');
                    
                    makeGridObjectDraggable(cell, emojiElement);
                    updateDragFeedback(`${objectData.name} placed successfully!`);
                    setTimeout(clearDragFeedback, 2000);
                } else {
                    updateDragFeedback(`Error: ${data.message}`);
                    setTimeout(clearDragFeedback, 3000);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                updateDragFeedback('Failed to place object');
                setTimeout(clearDragFeedback, 3000);
            });
        }

        function moveExistingObject(fromPosition, toPosition) {
            fetch('/move_object', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    from_position: fromPosition,
                    to_position: toPosition
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove from old position
                    const fromCell = document.querySelector(`[data-position="${fromPosition}"]`);
                    const emojiElement = fromCell.querySelector('.object-emoji');
                    const emojiText = emojiElement.textContent;
                    
                    fromCell.innerHTML = '';
                    fromCell.classList.remove('occupied');
                    
                    // Add to new position
                    const toCell = document.querySelector(`[data-position="${toPosition}"]`);
                    const newEmojiElement = document.createElement('span');
                    newEmojiElement.className = 'object-emoji';
                    newEmojiElement.textContent = emojiText;
                    
                    toCell.appendChild(newEmojiElement);
                    toCell.classList.add('occupied');
                    
                    makeGridObjectDraggable(toCell, newEmojiElement);
                    updateDragFeedback('Object moved successfully!');
                    setTimeout(clearDragFeedback, 2000);
                } else {
                    updateDragFeedback(`Error: ${data.message}`);
                    setTimeout(clearDragFeedback, 3000);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                updateDragFeedback('Failed to move object');
                setTimeout(clearDragFeedback, 3000);
            });
        }

        function enableRemovalMode() {
            removalMode = !removalMode;
            const button = document.getElementById('remove-object-btn');
            const instructions = document.getElementById('removal-instructions');
            
            if (removalMode) {
                button.textContent = 'Exit Remove Mode';
                button.style.backgroundColor = '#c0392b';
                instructions.style.display = 'block';
                document.body.style.cursor = 'crosshair';
                updateDragFeedback('Removal mode active - click objects to remove');
            } else {
                button.textContent = 'Remove Object Mode';
                button.style.backgroundColor = '#e74c3c';
                instructions.style.display = 'none';
                document.body.style.cursor = 'default';
                clearDragFeedback();
            }
        }

        function removeObject(position) {
            if (!removalMode) return;
            
            fetch('/remove_object', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    position: position
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const cell = document.querySelector(`[data-position="${position}"]`);
                    cell.innerHTML = '';
                    cell.classList.remove('occupied');
                    updateDragFeedback(`${data.removed.name} removed successfully!`);
                    setTimeout(clearDragFeedback, 2000);
                } else {
                    updateDragFeedback(`Error: ${data.message}`);
                    setTimeout(clearDragFeedback, 3000);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                updateDragFeedback('Failed to remove object');
                setTimeout(clearDragFeedback, 3000);
            });
        }

        function updateDragFeedback(message) {
            document.getElementById('drag-feedback').textContent = message;
        }

        function clearDragFeedback() {
            document.getElementById('drag-feedback').textContent = '';
        }

        // Position grid cells in flat grid layout
        function positionFlatGrid() {
            const gridCells = document.querySelectorAll('.grid-cell');
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            // Responsive cell sizing
            const cellWidth = isSmallMobile ? 16 : isMobile ? 20 : 30;
            const cellHeight = isSmallMobile ? 16 : isMobile ? 20 : 30;
            
            gridCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Flat grid positioning calculation
                const x = col * cellWidth;
                const y = row * cellHeight;
                
                cell.style.left = x + 'px';
                cell.style.top = y + 'px';
                
                // Add occupied class if cell has content
                if (cell.querySelector('.object-emoji')) {
                    cell.classList.add('occupied');
                }
            });
        }

        // Reposition grid on window resize
        window.addEventListener('resize', positionFlatGrid);

        // Escape key to cancel removal mode
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && removalMode) {
                enableRemovalMode(); // This will toggle it off
            }
        });
    </script>

</body>
</html> 
</html> 
